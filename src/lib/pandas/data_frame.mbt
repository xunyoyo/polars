///|
pub(all) struct DataFrame {
  mut data : Array[Series]
  mut shape : Array[Int]
  mut index : Map[String, Int]
} derive(Eq)

///|
pub impl Hash for DataFrame with hash_combine(self, hasher) {
  for idx in self.index {
    hasher.combine(idx.0)
    hasher.combine(idx.1)
    for col in self.data {
      hasher.combine(col)
    }
  }
}

///|
let emptyDataFrame : DataFrame = DataFrame::{
  data: [],
  shape: [0, 0],
  index: {},
}

///|
type! InconsistentSeriesLength String derive(Show)

///|
type! DuplicateColumnError String derive(Show)

///|
type! ColumnNotFoundError String derive(Show)

///|
type! IndexOutOfBounds String derive(Show)

///|
type! InvalidType String derive(Show)

///| Create a new DataFrame
///
/// ### Parameters
///
/// - `data` : Array of Series
///
/// ### Return
///
/// - `DataFrame!InconsistentSeriesLength` : A new DataFrame instance
///
/// ### Errors
///
/// - `InconsistentSeriesLength` : Raised if the lengths of the Series are not equal
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 1, 3, 1, 1, 6])),
///   Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
///   Series::new("C", SeriesData::Bool([true, false, true, false, true, false])),
///   Series::new("D", SeriesData::Str(["a", "b", "c", "d", "e", "f"])),
/// ])
/// ```
pub fn DataFrame::new(
  data : Array[Series]
) -> DataFrame!InconsistentSeriesLength {
  let index : Map[String, Int] = {}
  for i = 0; i < data.length(); i = i + 1 {
    if data[i].data().length() != data[0].data().length() {
      raise InconsistentSeriesLength(
        "Could not create a new DataFrame. The Series lengths are not equal.",
      )
    }
    index[data[i].name()] = i
  }
  DataFrame::{ data, shape: [data[0].data().length(), data.length()], index }
}

///|
pub fn DataFrame::shape(self : DataFrame) -> Array[Int] {
  self.shape
}

///|
pub fn DataFrame::data(self : DataFrame) -> Array[Series] {
  self.data
}

///| Trait Show for DataFrame
pub impl Show for DataFrame with output(self, logger) {
  let mut row_str = "\t"
  for col in self.data {
    row_str = row_str + col.name() + "\t"
  }
  logger.write_string(row_str + "\n")
  row_str = ""
  for i = 0; i < self.shape()[0]; i = i + 1 {
    row_str += i.to_string() + "\t"
    for col in self.data {
      match col.data() {
        SeriesData::Int(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Float(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Bool(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Str(vals) => row_str += vals[i] + "\t"
      }
    }
    row_str += "\n"
  }
  logger.write_string(row_str)
}

///| Display the first few rows of the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `num` : The number of rows to display (default is 5)
///
/// ### Return
///
/// - `Unit` : This function prints the first few rows of the DataFrame
///
/// ### Example
/// ```
/// df.head()
/// df.head(rows=3)
/// ```
pub fn DataFrame::head(self : DataFrame, rows~ : Int = 5) -> Unit {
  let mut row_str = "\t"
  for col in self.data {
    row_str = row_str + col.name() + "\t"
  }
  row_str += "\n"
  for i = 0; i < @math.minimum(rows, self.shape()[0]); i = i + 1 {
    row_str += i.to_string() + "\t"
    for col in self.data {
      match col.data() {
        SeriesData::Int(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Float(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Bool(vals) => row_str += vals[i].to_string() + "\t"
        SeriesData::Str(vals) => row_str += vals[i] + "\t"
      }
    }
    row_str += "\n"
  }
  println(row_str)
}

///| Add a new column to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col` : The Series to be added as a new column
///
/// ### Return
///
/// - `Unit!` : This function adds a new column to the DataFrame or raises an error
///
/// ### Errors
///
/// - `InconsistentSeriesLength`: Series length is not equal to the DataFrame length
/// - `DuplicateColumnError`: Series name already exists
///
/// ### Example
/// ```
/// let new_column = Series::new("B", SeriesData::Int([1, 2, 3]))
/// df.add_column(new_column)
/// ```
pub fn DataFrame::add_column(self : DataFrame, col : Series) -> Unit! {
  if col.data().length() != self.shape()[0] {
    raise InconsistentSeriesLength(
      "Could not add a new column to the DataFrame. The Series lengths are not equal.",
    )
  }
  if self.index.contains(col.name()) {
    raise DuplicateColumnError(
      "Could not add a new column to the DataFrame. The Series name already exists.",
    )
  }
  self.data += [col]
  self.shape = [self.shape()[0], self.shape()[1] + 1]
  self.index[col.name()] = self.shape()[1] - 1
}

///| Drop a column from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col_name` : The name of the column to be dropped
///
/// ### Return
///
/// - `Unit` : This function drops a column from the DataFrame
///
/// ### Example
/// ```
/// df.drop_column("column_name")
/// ```
pub fn DataFrame::drop_column(
  self : DataFrame,
  col_name : String
) -> Unit!ColumnNotFoundError {
  match self.index.get(col_name) {
    Some(idx) => {
      let _ = self.data.remove(idx)
      self.index.remove(col_name)
      self.shape = [self.shape()[0], self.shape()[1] - 1]
      self.index.each(fn(k, v) { if v > idx { self.index[k] = v - 1 } })
    }
    None => raise ColumnNotFoundError("Column '\{col_name}' not found")
  }
}

///| Rename a column in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `old_name` : The current name of the column to be renamed
/// - `new_name` : The new name for the column
///
/// ### Return
///
/// - `Unit` : This function renames a column in the DataFrame
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if the column is not found
///
/// ### Example
/// ```
/// test {
///   let mut df = DataFrame::new([Series::new("A", SeriesData::Int([1, 2]))])
///   df.rename("A", "B")
///   inspect!(df.data()[0].name(), context="B")
/// }
/// ```
pub fn DataFrame::rename(
  self : DataFrame,
  old_name : String,
  new_name : String
) -> Unit!ColumnNotFoundError {
  match self.index.get(old_name) {
    Some(idx) => self.data[idx].name = new_name
    None => raise ColumnNotFoundError("Column '\{old_name}' not found")
  }
}

///| Select a column from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col_name` : Column name to be selected
///
/// ### Return
///
/// - `Series` : Series contain selected columns
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if a column is not found
///
/// ### Example
/// ```
/// let col_selected = df.column("col_name")
/// ```
pub fn DataFrame::column(
  self : DataFrame,
  col_name : String
) -> Series!ColumnNotFoundError {
  match self.index.get(col_name) {
    Some(idx) => self.data[idx]
    None => raise ColumnNotFoundError("Column '\{col_name}' not found")
  }
}

///| Select specific columns from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `cols` : An array of column names to be selected
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the selected columns
/// 
/// ### Errors
/// 
/// - `ColumnNotFoundError` : Raised if a column is not found
///
/// ### Example
/// ```
/// let df_selected = df.select_columns(["col_name1", "col_name2"])
/// ```
pub fn DataFrame::select_columns(
  self : DataFrame,
  cols : Array[String]
) -> DataFrame!ColumnNotFoundError {
  let selected_cols : Array[Series] = []
  let index : Map[String, Int] = {}
  for name in cols {
    match self.index.get(name) {
      Some(idx) => {
        selected_cols.push(self.data[idx])
        index[name] = selected_cols.length() - 1
      }
      None => raise ColumnNotFoundError("Column '\{name}' not found")
    }
  }
  DataFrame::{
    data: selected_cols,
    shape: [self.shape()[0], selected_cols.length()],
    index,
  }
}

///| Drop a row from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `row` : The index of the row to be dropped
///
/// ### Return
///
/// - `Unit` : This function drops a row from the DataFrame
///
/// ### Errors
///
/// - `IndexOutOfBounds` : Raised if the row index is out of bounds
///
/// ### Example
/// ```
/// df.drop_row(0)
/// ```
pub fn DataFrame::drop_row(self : DataFrame, row_index : Int) -> Unit! {
  if row_index < 0 || row_index >= self.shape()[0] {
    raise IndexOutOfBounds("Row index out of bounds")
  }
  for col in self.data {
    col.data.erase!(row_index)
  }
  self.shape[0] = self.shape[0] - 1
}

///| Add a new row to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `row` : An array of DType representing the new row to be added
///
/// ### Return
///
/// - `Unit` : This function adds a new row to the DataFrame
///
/// ### Errors
///
/// - `InconsistentSeriesLength` : Raised if the row length does not match the DataFrame column length
/// - `InvalidType` : if there is a type mismatch
///
/// ### Example
/// ```
/// let mut df = DataFrame::new([
///   Series::new("A", SeriesData::Int([1, 2, 3])), 
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3]))
/// ])
/// df.add_row([DType::Int(4), DType::Float(4.4)])
/// ```
pub fn DataFrame::add_row(self : DataFrame, row : Array[DType]) -> Unit! {
  if row.length() != self.shape()[1] {
    raise InconsistentSeriesLength(
      "Row length does not match DataFrame column length",
    )
  }
  for i = 0; i < row.length(); i = i + 1 {
    match self.data[i].data {
      SeriesData::Int(data) =>
        match row[i] {
          DType::Int(value) => data.push(value)
          _ => raise InvalidType("Type mismatch")
        }
      SeriesData::Float(data) =>
        match row[i] {
          DType::Float(value) => data.push(value)
          _ => raise InvalidType("Type mismatch")
        }
      SeriesData::Bool(data) =>
        match row[i] {
          DType::Bool(value) => data.push(value)
          _ => raise InvalidType("Type mismatch")
        }
      SeriesData::Str(data) =>
        match row[i] {
          DType::Str(value) => data.push(value)
          _ => raise InvalidType("Type mismatch")
        }
    }
  }
  self.shape[0] = self.shape[0] + 1
}

///| Select specific rows from the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `range` : An optional tuple representing the range of rows to be selected (inclusive start, exclusive end)
/// - `indices` : An optional array of row indices to be selected
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the selected rows
/// 
/// ### Errors
/// 
/// - `IndexOutOfBounds` : Raised if the row index is out of bounds
///
/// ### Example
/// ```
/// let df_selected_range = df.select_rows(range=(1, 4))
/// 
/// let df_selected_indices = df.select_rows(indices=[1, 3, 5])
/// ```
pub fn DataFrame::select_rows(
  self : DataFrame,
  range? : (Int, Int),
  indices? : Array[Int]
) -> DataFrame!IndexOutOfBounds {
  match (range, indices) {
    (Some(_), Some(_)) | (Some(_), None) => {
      let selected_rows : Array[Series] = []
      for col in self.data {
        let (begin, end) = match range {
          Some(r) => r
          None => abort("Range is None")
        }
        let select_data = match col.data() {
          SeriesData::Int(data) =>
            SeriesData::Int(data.split_at(begin).1.split_at(end - begin).0)
          SeriesData::Float(data) =>
            SeriesData::Float(data.split_at(begin).1.split_at(end - begin).0)
          SeriesData::Bool(data) =>
            SeriesData::Bool(data.split_at(begin).1.split_at(end - begin).0)
          SeriesData::Str(data) =>
            SeriesData::Str(data.split_at(begin).1.split_at(end - begin).0)
        }
        selected_rows.push(Series::new(col.name(), select_data))
      }
      DataFrame::{
        data: selected_rows,
        shape: [selected_rows[0].data.length(), self.shape()[1]],
        index: self.index,
      }
    }
    (None, Some(_)) =>
      match indices {
        Some(i) => {
          i.sort()
          if i[0] < 0 || i[i.length() - 1] >= self.shape()[0] {
            raise IndexOutOfBounds("Row index out of bounds")
          }
          let selected_rows : Array[Series] = []
          for col in self.data {
            match col.data {
              SeriesData::Int(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                selected_rows.push(
                  Series::new(col.name(), SeriesData::Int(col_data)),
                )
              }
              SeriesData::Float(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                selected_rows.push(
                  Series::new(col.name(), SeriesData::Float(col_data)),
                )
              }
              SeriesData::Bool(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                selected_rows.push(
                  Series::new(col.name(), SeriesData::Bool(col_data)),
                )
              }
              SeriesData::Str(data) => {
                let col_data = []
                for idx in i {
                  col_data.push(data[idx])
                }
                selected_rows.push(
                  Series::new(col.name(), SeriesData::Str(col_data)),
                )
              }
            }
          }
          DataFrame::{
            data: selected_rows,
            shape: [selected_rows[0].data().length(), self.shape()[1]],
            index: self.index,
          }
        }
        None => emptyDataFrame
      }
    (None, None) => emptyDataFrame
  }
}

///|
pub fn op_get(self : DataFrame, index : Int) -> DataFrame {
  let row = []
  for col in self.data {
    match col.data {
      SeriesData::Int(data) =>
        row.push(Series::{
          name: col.name,
          data: SeriesData::Int([data[index]]),
        })
      SeriesData::Float(data) =>
        row.push(Series::{
          name: col.name,
          data: SeriesData::Float([data[index]]),
        })
      SeriesData::Bool(data) =>
        row.push(Series::{
          name: col.name,
          data: SeriesData::Bool([data[index]]),
        })
      SeriesData::Str(data) =>
        row.push(Series::{
          name: col.name,
          data: SeriesData::Str([data[index]]),
        })
    }
  }
  DataFrame::{ data: row, shape: [1, self.shape()[1]], index: self.index }
}

///| Filter rows in the DataFrame based on a condition
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `name` : The name of the column to apply the filter on
/// - `f` : A function that takes a `DType` and returns a `Bool` indicating whether the row should be included
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame containing only the rows that satisfy the condition
///
/// ### Example
/// ```
/// let df = DataFrame::new([Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6]))])
/// let filtered = df.filter("A", fn(x) -> Bool { x < DType::Int(3) })
/// ```
pub fn DataFrame::filter(
  self : DataFrame,
  name : String,
  f : (DType) -> Bool
) -> DataFrame! {
  match self.index.get(name) {
    Some(index) =>
      match self.data[index].data() {
        SeriesData::Int(data) => {
          let rows = Array::new()
          for i = 0; i < data.length(); i = i + 1 {
            if f(DType::Int(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows!(indices=rows)
        }
        SeriesData::Float(data) => {
          let rows = Array::new()
          for i = 0; i < data.length(); i = i + 1 {
            if f(DType::Float(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows!(indices=rows)
        }
        SeriesData::Bool(data) => {
          let rows = Array::new()
          for i = 0; i < data.length(); i = i + 1 {
            if f(DType::Bool(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows!(indices=rows)
        }
        SeriesData::Str(data) => {
          let rows = Array::new()
          for i = 0; i < data.length(); i = i + 1 {
            if f(DType::Str(data[i])) {
              rows.push(i)
            }
          }
          self.select_rows!(indices=rows)
        }
      }
    None => emptyDataFrame
  }
}

///| Sort the DataFrame by a specified column
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `col_name` : The name of the column to sort by
/// - `descending~` : Whether to sort in descending order (default is false)
///
/// ### Return
///
/// - `Unit` : This function sorts the DataFrame in place
///
/// ### Errors
///
/// - `ColumnNotFoundError` : Raised if the specified column is not found
///
/// ### Example
/// ```
/// let df = DataFrame::new([
///   Series::new("A", SeriesData::Int([3, 1, 2])), 
///   Series::new("B", SeriesData::Float([3.3, 1.1, 2.2]))
/// ])
/// df.sort("A", descending=true)
/// inspect!(df.data()[0].data(), content="Int([1, 2, 3])")
/// ```
pub fn DataFrame::sort(
  self : DataFrame,
  col_name : String,
  descending~ : Bool = false
) -> Unit!ColumnNotFoundError {
  match self.index.get(col_name) {
    Some(index) => {
      let indices = self.data[index].data.get_argsort_indices(descending~)
      for item in self.data {
        item.data.argsort_indices(indices)
      }
    }
    None => raise ColumnNotFoundError("Column '\{col_name}' not found.")
  }
}

///| Vertically stack two DataFrames
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `other` : Another DataFrame to be stacked vertically
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame resulting from the vertical stacking of the two DataFrames
///
/// ### Errors
///
/// - `InconsistentSeriesLength` : Raised if the number of columns in the two DataFrames is not the same
/// - `InvalidType` : Raised if the data types of the corresponding columns in the two DataFrames are not the same
///
/// ### Example
/// ```
/// let df1 = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3]))
/// ])
/// let df2 = DataFrame::new!([
///   Series::new("A", SeriesData::Int([4, 5, 6]))
/// ])
/// let df_stacked = df1.vstack!(df2)
/// ```
pub fn vstack(self : DataFrame, other : DataFrame) -> DataFrame! {
  if self.shape()[1] != other.shape()[1] {
    raise InconsistentSeriesLength("The number of columns must be the same.")
  }
  let data : Array[Series] = []
  for series in self.data {
    match (series.data, other.column!(series.name).data) {
      (SeriesData::Int(data1), SeriesData::Int(data2)) => {
        let new_data = data1 + data2
        data.push(Series::new(series.name, SeriesData::Int(new_data)))
      }
      (SeriesData::Float(data1), SeriesData::Float(data2)) => {
        let new_data = data1 + data2
        data.push(Series::new(series.name, SeriesData::Float(new_data)))
      }
      (SeriesData::Bool(data1), SeriesData::Bool(data2)) => {
        let new_data = data1 + data2
        data.push(Series::new(series.name, SeriesData::Bool(new_data)))
      }
      (SeriesData::Str(data1), SeriesData::Str(data2)) => {
        let new_data = data1 + data2
        data.push(Series::new(series.name, SeriesData::Str(new_data)))
      }
      _ => raise InvalidType("The data types must be the same.")
    }
  }
  DataFrame::new!(data)
}

///| Horizontally stack two DataFrames
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `other` : Another DataFrame to be stacked horizontally
///
/// ### Return
///
/// - `DataFrame` : A new DataFrame resulting from the horizontal stacking of the two DataFrames
///
/// ### Example
/// ```
/// let df1 = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3]))
/// ])
/// let df2 = DataFrame::new!([
///   Series::new("B", SeriesData::Int([4, 5, 6]))
/// ])
/// let df_stacked = df1.hstack!(df2)
/// ```
pub fn hstack(self : DataFrame, other : DataFrame) -> DataFrame! {
  let data : Array[Series] = other.data.copy()
  for series in self.data {
    if other.index.contains(series.name()) == false {
      data.push(series)
    }
  }
  DataFrame::new!(data)
}

///|
/// Clears all data in the DataFrame, resetting it to an empty state.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to be cleared.
/// - `n` : Optional parameter that specifies a size hint for clearing (default
/// is 0). Currently not used.
///
/// ### Example:
///
/// ```moonbit
/// df.clear!()
/// ```
pub fn DataFrame::clear(self : DataFrame) -> Unit {
  for item in self.data {
    item.data.clear()
  }
  self.shape = [0, 0]
  self.index.clear()
}

///|
/// Creates a deep copy of the DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to be cloned.
///
/// ### Return:
/// Return a new DataFrame with the same data, shape, and index as the original
/// DataFrame. All internal data structures are deeply copied.
/// THIS METHOD Under Consideration...
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.0, 2.0, 3.0])),
/// ])
/// let cloned = df.clone()
/// ```
pub fn DataFrame::clone(self : DataFrame) -> DataFrame {
  let data = self.data.map(fn(series : Series) { series.copy() })
  let index = self.index.iter().collect()
  let map : Map[String, Int] = {}
  for idx in index {
    map[idx.0] = idx.1
  }
  DataFrame::{ data, shape: self.shape.copy(), index: map }
}

///|
pub(all) enum ColumnSelector {
  Int(Int)
  Str(String)
}

///|
/// Retrieves a single item from the DataFrame at the specified row and column.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to retrieve the item from.
/// - `row` : The index of the row (zero-based).
/// - `column` : The column identifier, can be either:
///  * `ColumnSelector::Int`: A zero-based index of the column
///  * `ColumnSelector::Str`: The name of the column
///
/// Returns a `DType` value representing the item at the specified position.
///
/// Throws:
///
/// - `ColumnNotFoundError` : If the specified column name does not exist in the
/// DataFrame
/// - `IndexOutOfBounds` : If the row index is out of range
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.0, 3.5])),
/// ])
/// df.item!(1, ColumnSelector::Str("A"))
/// df.item!(0, ColumnSelector::Int(1))
/// ```
pub fn DataFrame::item(
  self : DataFrame,
  row : Int,
  column : ColumnSelector
) -> DType!Error {
  let col = match column {
    ColumnSelector::Int(value) => value
    ColumnSelector::Str(value) =>
      match self.index.get(value) {
        Some(idx) => idx
        None => raise ColumnNotFoundError("Column '\{value}' not found")
      }
  }
  if row < 0 || row >= self.shape()[0] || col < 0 || col >= self.shape()[1] {
    raise IndexOutOfBounds("Row index out of bounds")
  }
  self.data[col][row]
}

///|
/// Creates a new DataFrame containing only the first N rows of the original
/// DataFrame. If N is larger than the number of rows in the DataFrame, returns a
/// DataFrame with all rows from the original DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to limit.
/// - `n` : The maximum number of rows to include in the new DataFrame.
///
/// ### Return:
/// 
/// Return a new DataFrame containing at most N rows from the original
/// DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
/// ])
/// let limited = df.limit!(3)
/// ```
pub fn limit(self : DataFrame, n : Int) -> DataFrame!Error {
  let data : Array[Series] = []
  let n = @math.minimum(n, self.shape()[0])
  for series in self.data {
    let new_data = match series.data {
      SeriesData::Int(data) => SeriesData::Int(data.split_at(n).0)
      SeriesData::Float(data) => SeriesData::Float(data.split_at(n).0)
      SeriesData::Bool(data) => SeriesData::Bool(data.split_at(n).0)
      SeriesData::Str(data) => SeriesData::Str(data.split_at(n).0)
    }
    data.push(Series::new(series.name, new_data))
  }
  DataFrame::new!(data)
}

///|
/// Creates a new DataFrame containing only the last N rows of the original
/// DataFrame. If N is larger than the number of rows in the DataFrame, returns a
/// DataFrame with all rows from the original DataFrame.
///
/// ### Parameters:
///
/// - `self` : The DataFrame to extract rows from.
/// - `n` : The number of rows to include from the end of the DataFrame.
///
/// ### Return:
/// 
/// Returns a new DataFrame containing at most N rows from the end of the
/// original DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// ### Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
/// ])
/// let last_three = df.tail!(3)
/// ```
pub fn tail(self : DataFrame, n : Int) -> DataFrame!Error {
  let data : Array[Series] = []
  let n = @math.minimum(n, self.shape()[0])
  for series in self.data {
    let new_data = match series.data {
      SeriesData::Int(data) =>
        SeriesData::Int(data.split_at(data.length() - n).1)
      SeriesData::Float(data) =>
        SeriesData::Float(data.split_at(data.length() - n).1)
      SeriesData::Bool(data) =>
        SeriesData::Bool(data.split_at(data.length() - n).1)
      SeriesData::Str(data) =>
        SeriesData::Str(data.split_at(data.length() - n).1)
    }
    data.push(Series::new(series.name, new_data))
  }
  DataFrame::new!(data)
}

///|
/// Creates a new DataFrame containing a slice of rows from the original
/// DataFrame, starting from the specified offset.
///
/// Parameters:
///
/// * `self` : The DataFrame to slice.
/// * `offset` : The starting index of the slice (zero-based).
/// * `length` : Optional parameter specifying the number of rows to include in
/// the slice. If not provided, includes all remaining rows after the offset.
///
/// Returns a new DataFrame containing the specified slice of rows from the
/// original DataFrame.
///
/// Throws an error of type `Error` if creating the new DataFrame fails.
///
/// Example:
///
/// ```moonbit
///   let df = DataFrame::new!([
///     Series::new("A", SeriesData::Int([1, 2, 3, 4, 5])),
///     Series::new("B", SeriesData::Float([1.1, 2.2, 3.3, 4.4, 5.5])),
///   ])
///   let sliced = df.slice!(1, length=2)
/// ```
pub fn DataFrame::slice(
  self : DataFrame,
  offset : Int,
  length~ : Int = self.shape()[0] - offset
) -> DataFrame!Error {
  let data : Array[Series] = []
  let len = length
  for series in self.data {
    let new_data = match series.data {
      SeriesData::Int(data) =>
        SeriesData::Int(data.split_at(offset).1.split_at(len).0)
      SeriesData::Float(data) =>
        SeriesData::Float(data.split_at(offset).1.split_at(len).0)
      SeriesData::Bool(data) =>
        SeriesData::Bool(data.split_at(offset).1.split_at(len).0)
      SeriesData::Str(data) =>
        SeriesData::Str(data.split_at(offset).1.split_at(len).0)
    }
    data.push(Series::new(series.name, new_data))
  }
  DataFrame::new!(data)
}

///|
/// Splits a DataFrame into two parts at the specified index.
///
/// Parameters:
///
/// * `self` : The DataFrame to be split.
/// * `offset` : The index at which to split the DataFrame. The first DataFrame
/// will contain rows \[0, offset), and the second DataFrame will contain rows
/// \[offset, length).
///
/// Returns a tuple containing two DataFrames: the first containing rows before
/// the offset, and the second containing rows from the offset onwards.
///
/// Throws an error if the offset is out of bounds or if creating the new
/// DataFrames fails.
///
/// Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3, 4])),
///   Series::new("B", SeriesData::Float([1.5, 2.5, 3.5, 4.5])),
/// ])
/// let (df1, df2) = df.split_at!(2)
/// ```
pub fn DataFrame::split_at(self : DataFrame, offset: Int) -> (DataFrame, DataFrame)!Error {
  let slice1 = self.slice!(0, length=offset)
  let slice2 = self.slice!(offset)
  (slice1, slice2)
}

test "DataFrame::split_at" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4])),
    Series::new("B", SeriesData::Float([1.5, 2.5, 3.5, 4.5])),
  ])
  let (df1, df2) = df.split_at!(2)
  inspect!(df1.shape(), content="[2, 2]")
  inspect!(df2.shape(), content="[2, 2]")
  inspect!(df1.data()[0].data(), content="Int([1, 2])")
  inspect!(df2.data()[0].data(), content="Int([3, 4])")
}

test "DataFrame::split_at/zero" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.5, 3.5])),
  ])
  let (df1, df2) = df.split_at!(0)
  inspect!(df1.shape(), content="[0, 2]")
  inspect!(df2.shape(), content="[3, 2]")
}

test "panic DataFrame::split_at/negative_offset" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.5, 3.5])),
  ])
  ignore(df.split_at!(-1))
}

///|
/// Converts a column of the DataFrame to a Series by its index.
///
/// Parameters:
///
/// * `self` : The DataFrame from which to extract the Series.
/// * `column_index` : The zero-based index of the column to convert to a Series.
///
/// Returns the Series at the specified column index.
///
/// Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.0, 2.5])),
/// ])
/// df.to_series(0)
/// ```
pub fn to_series(self : DataFrame, index : Int) -> Series {
  self.data[index]
}

///|
/// Removes duplicate rows from the DataFrame based on specified columns, with
/// control over which duplicates to keep.
///
/// Parameters:
///
/// * `df` : The DataFrame to remove duplicates from.
/// * `columns` : An array of column names to consider when identifying
/// duplicates. Rows are considered duplicates if they have the same values in
/// all specified columns.
/// * `keep~` : A string specifying which duplicates to retain. Valid values are:
///  * "first": Keep the first occurrence of each duplicate
///  * "last": Keep the last occurrence of each duplicate
///  * "any": Keep any occurrence of each duplicate (defaults to first)
///  * "none": Keep only rows that have no duplicates
///
/// Returns a new DataFrame with duplicates removed according to the specified
/// criteria.
///
/// Throws:
///
/// * `InvalidType` : If an invalid value is provided for the `keep` parameter
/// * `ColumnNotFoundError` : If any of the specified columns do not exist in the
/// DataFrame
///
/// Example:
///
/// ```moonbit
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 1, 2, 2])),
///   Series::new("B", SeriesData::Int([1, 1, 2, 3])),
/// ])
/// let unique_df = df.unique!(["A"], keep="first")
/// ```
pub fn unique(
  self : DataFrame,
  subset : Array[String],
  keep~ : String = "any"
) -> DataFrame!Error {
  if not(["first", "last", "any", "none"].contains(keep)) {
    raise InvalidType(
      "Invalid keep parameter. Must be one of: first, last, any, none",
    )
  }
  let selected_cols = []
  for item in subset {
    selected_cols.push(self.column!(item))
  }
  let df = DataFrame::new!(selected_cols)
  let unique_map = Map::new() // key: row_string, value: Array[Int]
  for i = 0; i < df.shape()[0]; i = i + 1 {
    let row_key = df.select_rows!(range=(i, i + 1)).to_string()
    if unique_map.contains(row_key) {
      let current_indices = match unique_map.get(row_key) {
        Some(indices) => indices
        None => []
      }
      let new_indices = current_indices + [i]
      unique_map.set(row_key, new_indices)
    } else {
      unique_map.set(row_key, [i])
    }
  }
  let unique_indices = Array::new()
  for indice in unique_map {
    let indices = indice.1
    match keep {
      "first" => unique_indices.push(indices[0])
      "last" => unique_indices.push(indices[indices.length() - 1])
      "any" => unique_indices.push(indices[0])
      _ => if indices.length() == 1 { unique_indices.push(indices[0]) }
    }
  }
  unique_indices.sort()
  match unique_indices.length() {
    0 => emptyDataFrame
    _ => self.select_rows!(indices=unique_indices)
  }
}

///| Replace a column in the DataFrame at a specified index
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `index` : The index of the column to be replaced
/// - `series` : The new Series to replace the existing column
///
/// ### Errors
///
/// - `IndexOutOfBounds` : Raised if the specified index is out of bounds
/// - `InconsistentSeriesLength` : Raised if the length of the new Series does not match the number of rows in the DataFrame
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.1, 2.2, 3.3]))
/// ])
/// let new_series = Series::new("C", SeriesData::Int([4, 5, 6]))
/// df.replace_column(1, new_series)
/// ```
pub fn DataFrame::replace_column(
  self : DataFrame,
  index : Int,
  series : Series
) -> Unit! {
  guard index >= 0 && index < self.shape[1] else {
    raise IndexOutOfBounds("Index out of bounds")
  }
  guard series.data.length() == self.shape[0] else {
    raise InconsistentSeriesLength("The number of columns must be the same")
  }
  self.data[index] = series
}

///| Reverse the order of rows in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Example
/// ```moonbit
/// df.reverse()
/// ```
pub fn DataFrame::reverse(self : DataFrame) -> Unit {
  for series in self.data {
    series.reverse()
  }
}

///| Get the index of a column by its name
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `name` : The name of the column
///
/// ### Errors
///
/// - `ColumnNotFoundError` : Raised if the specified column is not found
///
/// ### Example
/// ```moonbit
/// let index = df.get_column_index("A")
/// ```
pub fn DataFrame::get_column_index(self : DataFrame, name : String) -> Int! {
  match self.index.get(name) {
    Some(index) => index
    None => raise ColumnNotFoundError("Column '\{name}' not found")
  }
}

///| Add a row index column to the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `offset` : An optional integer offset to start the row index (default is 0)
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame with an added row index column
///
/// ### Example
/// ```
/// let df_with_index = df.with_row_index()
/// ```
pub fn DataFrame::with_row_index(
  self : DataFrame,
  offset~ : Int = 0
) -> DataFrame {
  let new_data = self.data.copy()
  let idx = Series::new(
    "index",
    SeriesData::Int(Array::makei(self.shape[0], fn(i) { i + offset })),
  )
  new_data.insert(0, idx)
  let new_index = { "row_nr": 0 }
  for item in self.index {
    new_index[item.0] = item.1 + 1
  }
  DataFrame::{
    data: new_data,
    shape: [self.shape[0], self.shape[1] + 1],
    index: new_index,
  }
}

///| Transpose a DataFrame over the diagonal
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
/// - `include_header~` : If set, the column names will be added as first column. (default is false)
/// - `header_name~` : If include_header is set, this determines the name of the column that will be inserted. (default is "column")
/// - `column_names?` : Optional iterable yielding strings or a string naming an existing column. These will name the value (non-header) columns in the transposed data.
///
/// ### Returns
///
/// - `DataFrame` : A new transposed DataFrame
///
/// ### Errors
///
/// - `InvalidType` : Raised if the columns have different data types
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Int([4, 5, 6]))
/// ])
/// let df_transposed = df.transpose()
/// let df_transposed = df.transpose(include_header=true)
/// let df_transposed = df.transpose(include_header=true, header_name="header")
/// let df_transposed = df.transpose(column_names=["x","y"])
/// ```
pub fn DataFrame::transpose(
  self : DataFrame,
  include_header~ : Bool = false,
  header_name~ : String = "column",
  column_names? : Array[String]
) -> DataFrame! {
  for series in self.data {
    if series.get_type() != self.data[0].get_type() {
      raise InvalidType("All columns must have the same data type")
    }
  }
  let new_data : Array[Series] = []
  match include_header {
    true => {
      let header = Series::new(
        header_name,
        SeriesData::Str(
          Array::makei(self.shape[1], fn(i) { self.data[i].name }),
        ),
      )
      new_data.push(header)
    }
    false => ()
  }
  match self.data[0][0] {
    Int(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            DType::Int(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(Series::new(col_name, SeriesData::Int(col_data)))
      }
    Float(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            DType::Float(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(Series::new(col_name, SeriesData::Float(col_data)))
      }
    Bool(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            DType::Bool(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(Series::new(col_name, SeriesData::Bool(col_data)))
      }
    Str(_) =>
      for i = 0; i < self.shape[0]; i = i + 1 {
        let col_data = []
        for j = 0; j < self.shape[1]; j = j + 1 {
          match self.data[j][i] {
            DType::Str(value) => col_data.push(value)
            _ => ()
          }
        }
        let col_name = "column_" + i.to_string()
        new_data.push(Series::new(col_name, SeriesData::Str(col_data)))
      }
  }
  match column_names {
    Some(names) =>
      for i = 0; i < @math.minimum(names.length(), new_data.length()); i = i + 1 {
        new_data[i].name = names[i]
      }
    None => ()
  }
  let new_index : Map[String, Int] = {}
  for i = 0; i < new_data.length(); i = i + 1 {
    new_index[new_data[i].name] = i
  }
  DataFrame::{
    data: new_data,
    shape: [new_data[0].data.length(), new_data.length()],
    index: new_index,
  }
}

///| Aggregate the columns of this DataFrame to their minimum value
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the minimum value of each column
///
/// ### Example
/// ```
/// let df_min = df.min()
/// ```
pub fn DataFrame::min(self : DataFrame) -> DataFrame! {
  let data : Array[Series] = []
  for series in self.data {
    let min = series.min!()
    match min {
      DType::Float(value) =>
        data.push(Series::new(series.name, SeriesData::Float([value])))
      DType::Int(value) =>
        data.push(Series::new(series.name, SeriesData::Int([value])))
      DType::Bool(value) =>
        data.push(Series::new(series.name, SeriesData::Bool([value])))
      DType::Str(value) =>
        data.push(Series::new(series.name, SeriesData::Str([value])))
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Get the minimum value horizontally across columns.
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the minimum value of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let max = df.min_horizontal()
/// ```
pub fn DataFrame::min_horizontal(self : DataFrame) -> Series! {
  for series in self.data {
    match series.get_type() {
      BasicType::Int => ()
      BasicType::Float => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], @float.max_value)),
  }
  for series in self.data {
    data.data.min(series.data)
  }
  data
}

///| Aggregate the columns of this DataFrame to their maximum value
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the maximum value of each column
///
/// ### Example
/// ```
/// let df_min = df.max()
/// ```
pub fn DataFrame::max(self : DataFrame) -> DataFrame! {
  let data : Array[Series] = []
  for series in self.data {
    let max = series.max!()
    match max {
      DType::Float(value) =>
        data.push(Series::new(series.name, SeriesData::Float([value])))
      DType::Int(value) =>
        data.push(Series::new(series.name, SeriesData::Int([value])))
      DType::Bool(value) =>
        data.push(Series::new(series.name, SeriesData::Bool([value])))
      DType::Str(value) =>
        data.push(Series::new(series.name, SeriesData::Str([value])))
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Get the maximum value horizontally across columns.
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the maximum value of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let max = df.max_horizontal()
/// ```
pub fn DataFrame::max_horizontal(self : DataFrame) -> Series! {
  for series in self.data {
    match series.get_type() {
      BasicType::Int => ()
      BasicType::Float => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], @float.min_value)),
  }
  for series in self.data {
    data.data.max(series.data)
  }
  data
}

///| Calculate the sum of each column in the DataFrame
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `DataFrame` : A new DataFrame containing the sum of each column
///
/// ### Errors
///
/// - `InvalidType` : Raised if the Series data type is not supported
///
/// ### Example
/// ```
/// let df_sum = df.sum()
/// ```
pub fn DataFrame::sum(self : DataFrame) -> DataFrame!InvalidType {
  let data : Array[Series] = []
  for series in self.data {
    let sum = series.sum!()
    match sum {
      DType::Float(value) =>
        data.push(Series::new(series.name, SeriesData::Float([value])))
      DType::Int(value) =>
        data.push(Series::new(series.name, SeriesData::Int([value])))
      _ => ()
    }
  }
  DataFrame::{ data, shape: [1, self.shape[1]], index: self.index }
}

///| Sum all values horizontally across columns
///
/// ### Parameters
///
/// - `self` : An instance of the DataFrame
///
/// ### Returns
///
/// - `Series` : A Series containing the sum of each row
///
/// ### Errors
///
/// - `InvalidType` : Raised if the DataFrame contains unsupported data types
///
/// ### Example
/// ```
/// let df = DataFrame::new!([
///   Series::new("A", SeriesData::Int([1, 2, 3])),
///   Series::new("B", SeriesData::Float([1.5, 2.5, 3.0]))
/// ])
/// let sum = df.sum_horizontal!()
/// ```
pub fn DataFrame::sum_horizontal(self : DataFrame) -> Series! {
  for series in self.data {
    match series.get_type() {
      BasicType::Int => ()
      BasicType::Float => ()
      _ => raise InvalidType("Contains unsupported data type")
    }
  }
  let mut data = Series::{
    name: "sum",
    data: SeriesData::Float(Array::make(self.shape[0], (0.0 : Float))),
  }
  for series in self.data {
    data += series
  }
  data
}

///|
/// NOT USABLE!!!
/// Applies a transformation function to a column in the DataFrame, modifying the
/// column in place.
///
/// Parameters:
///
/// * `self` : The DataFrame instance to modify.
/// * `column_name` : The name of the column to apply the transformation to.
/// * `transform` : A function that takes a value of type `T` and returns a value
/// of type `R`. This function will be applied to each element in the specified
/// column.
///
/// Throws:
///
/// * `ColumnNotFoundError` : If the specified column does not exist in the
/// DataFrame.
/// * `IndexOutOfBounds` : If attempting to access invalid indices during column
/// replacement.
/// * `InvalidType` : If the transformation function's input type doesn't match
/// the column's data type.
///
/// Example:
///
/// ```moonbit
/// let mut df = DataFrame::new!([Series::new("A", SeriesData::Int([1, 2, 3]))])
/// df.apply!("A", fn(x : Int) -> Int { x * 2 })
/// ```
pub fn DataFrame::apply[T, R](self : DataFrame, name : String, f : (T) -> R) -> Unit!Error {
  let col = self.column!(name)
  let new_data = col.apply(f)
  self.replace_column!(self.get_column_index!(name), new_data)
}

///| Tests
test "new" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 6.0, 6.0, 6.0])),
    Series::new("C", SeriesData::Bool([true, false, true, false, true, false])),
    Series::new("D", SeriesData::Str(["a", "b", "c", "d", "e", "f"])),
  ])
  inspect!(df.shape(), content="[6, 4]")
}

test "add_drop_rename" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
    Series::new("C", SeriesData::Bool([true, false, true, false, true, false])),
    Series::new("D", SeriesData::Str(["a", "b", "c", "d", "e", "f"])),
  ])
  df.add_column!(Series::new("E", SeriesData::Int([7, 8, 9, 10, 11, 12])))
  inspect!(df.shape(), content="[6, 5]")
  df.drop_column!("E")
  inspect!(df.shape(), content="[6, 4]")
  df.rename!("A", "A1")
  inspect!(df.data()[0].name(), content="A1")
  df.drop_row!(0)
  df.add_row!([
    DType::Int(7),
    DType::Float(7.5),
    DType::Bool(true),
    DType::Str("g"),
  ])
  inspect!(df.shape(), content="[6, 4]")
}

test "select" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
    Series::new("C", SeriesData::Bool([true, false, true, false, true, false])),
    Series::new("D", SeriesData::Str(["a", "b", "c", "d", "e", "f"])),
  ])
  let col_selected = df.select_columns!(["A", "B"])
  inspect!(col_selected.shape(), content="[6, 2]")
  let row_selected = df.select_rows!(range=(1, 3))
  inspect!(row_selected.shape(), content="[2, 4]")
  let row_selected = df.select_rows!(indices=[1, 3, 5])
  inspect!(row_selected.shape(), content="[3, 4]")
}

test "filter" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 1, 3, 1, 1, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
    Series::new("C", SeriesData::Bool([true, false, true, false, true, false])),
    Series::new("D", SeriesData::Str(["a", "b", "c", "d", "e", "f"])),
  ])
  let filtered = df.filter!("A", fn(x) -> Bool { x < DType::Int(3) })
  inspect!(filtered.shape(), content="[4, 4]")
}

test "sort" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([2, 1, 3, 5, 4])),
    Series::new("B", SeriesData::Float([2.2, 1.1, 3.3, 5.5, 4.4])),
    Series::new("C", SeriesData::Bool([true, false, true, false, true])),
    Series::new("D", SeriesData::Str(["b", "a", "c", "e", "d"])),
  ])
  df.sort!("A")
  inspect!(df.data()[0].data(), content="Int([1, 2, 3, 4, 5])")
  df.sort!("A", descending=true)
  inspect!(df.data()[0].data(), content="Int([5, 4, 3, 2, 1])")
  inspect!(
    df.data()[3].data(),
    content="Str([\"e\", \"d\", \"c\", \"b\", \"a\"])",
  )
}

test "new_error" {
  let col1 = Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6]))
  let col2 = Series::new("B", SeriesData::Float([1.5, 2.0, 3.5]))
  let res = DataFrame::new?([col1, col2])
  inspect!(
    res,
    content="Err(InconsistentSeriesLength(\"Could not create a new DataFrame. The Series lengths are not equal.\"))",
  )
}

test "add_column_error" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
  ])
  let col = Series::new("B", SeriesData::Int([1, 2, 3, 4, 5, 6]))
  let res = df.add_column?(col)
  inspect!(
    res,
    content="Err(DuplicateColumnError(\"Could not add a new column to the DataFrame. The Series name already exists.\"))",
  )
  let res = df.add_column?(Series::new("C", SeriesData::Int([1, 2, 3])))
  inspect!(
    res,
    content="Err(InconsistentSeriesLength(\"Could not add a new column to the DataFrame. The Series lengths are not equal.\"))",
  )
}

test "drop_column_error" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
  ])
  let res = df.drop_column?("C")
  inspect!(res, content="Err(ColumnNotFoundError(\"Column 'C' not found\"))")
}

test "rename_column_error" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3, 4, 5, 6])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5, 4.0, 5.5, 6.0])),
  ])
  let res = df.rename?("C", "D")
  inspect!(res, content="Err(ColumnNotFoundError(\"Column 'C' not found\"))")
}

test "vstack" {
  let df1 = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Str(["a", "b", "c"])),
  ])
  let df2 = DataFrame::new!([
    Series::new("A", SeriesData::Int([4, 5, 6])),
    Series::new("B", SeriesData::Str(["d", "e", "f"])),
  ])
  let res = df1.vstack!(df2)
  inspect!(res.shape(), content="[6, 2]")
  inspect!(res.data()[0].data(), content="Int([1, 2, 3, 4, 5, 6])")
  inspect!(
    res.data()[1].data(),
    content="Str([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])",
  )
}

test "hstack" {
  let df1 = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Str(["a", "b", "c"])),
  ])
  let df2 = DataFrame::new!([
    Series::new("A", SeriesData::Int([4, 5, 6])),
    Series::new("C", SeriesData::Str(["d", "e", "f"])),
  ])
  let res = df1.hstack!(df2)
  inspect!(res.shape(), content="[3, 3]")
  inspect!(res.column!("A"), content="{name: \"A\", data: Int([4, 5, 6])}")
  inspect!(
    res.column!("B"),
    content="{name: \"B\", data: Str([\"a\", \"b\", \"c\"])}",
  )
  inspect!(
    res.column!("C"),
    content="{name: \"C\", data: Str([\"d\", \"e\", \"f\"])}",
  )
}

test "item" {
  let df = DataFrame::new!([Series::new("A", SeriesData::Int([1, 2, 3]))])
  inspect!(df.item?(1, ColumnSelector::Str("A")), content="Ok(Int(2))")
  inspect!(
    df.item?(0, ColumnSelector::Int(2)),
    content="Err(IndexOutOfBounds(\"Row index out of bounds\"))",
  )
}

test "unique/basic" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 1, 2, 2])),
    Series::new("B", SeriesData::Int([1, 1, 2, 3])),
  ])
  let unique_first = df.unique!(["A"], keep="first")
  inspect!(unique_first.shape(), content="[2, 2]")
  inspect!(unique_first.data()[0].data(), content="Int([1, 2])")
}

test "unique/empty" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([])),
    Series::new("B", SeriesData::Int([])),
  ])
  let unique_df = df.unique!(["A"])
  inspect!(unique_df.shape(), content="[0, 0]")
}

test "panic unique/invalid_keep" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 1, 2, 2])),
    Series::new("B", SeriesData::Int([1, 1, 2, 3])),
  ])
  df.unique!(["A"], keep="invalid") |> ignore
}

test "op_get" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Str(["a", "b", "c"])),
  ])
  let res = df[1]
  inspect!(res.shape(), content="[1, 2]")
  inspect!(res.data()[0].data(), content="Int([2])")
  inspect!(res.data()[1].data(), content="Str([\"b\"])")
}

test "replace_column" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Str(["a", "b", "c"])),
  ])
  df.replace_column!(1, Series::new("C", SeriesData::Int([4, 5, 6])))
  inspect!(df.data()[1].data(), content="Int([4, 5, 6])")
}

test "reverse" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Str(["a", "b", "c"])),
  ])
  df.reverse()
  inspect!(df.data[0].data, content="Int([3, 2, 1])")
  inspect!(df.data[1].data, content="Str([\"c\", \"b\", \"a\"])")
}

test "row_index" {
  let df = DataFrame::new!([Series::new("A", SeriesData::Int([1, 2, 3]))])
  let new_df = df.with_row_index(offset=1000)
  inspect!(new_df.shape, content="[3, 2]")
  inspect!(new_df.data[0].data, content="Int([1000, 1001, 1002])")
}

test "transpose" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Int([4, 5, 6])),
  ])
  let trans_df = df.transpose!()
  inspect!(trans_df.shape(), content="[2, 3]")
  let trans_df = df.transpose!(include_header=true)
  inspect!(trans_df.data[0].data(), content="Str([\"A\", \"B\"])")
  let trans_df = df.transpose!(include_header=true, header_name="header")
  inspect!(trans_df.data[0].data(), content="Str([\"A\", \"B\"])")
  inspect!(trans_df.data[0].name, content="header")
  let trans_df = df.transpose!(include_header=true, column_names=["x", "y", "z"])
  inspect!(trans_df.data[1].name, content="y")
}

test "min/max" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5])),
    Series::new("C", SeriesData::Bool([true, false, true])),
    Series::new("D", SeriesData::Str(["a", "b", "c"])),
  ])
  let min = df.min!()
  inspect!(
    min.data,
    content="[{name: \"A\", data: Int([1])}, {name: \"B\", data: Float([1.5])}, {name: \"C\", data: Bool([false])}, {name: \"D\", data: Str([\"a\"])}]",
  )
  let max = df.max!()
  inspect!(
    max.data,
    content="[{name: \"A\", data: Int([3])}, {name: \"B\", data: Float([3.5])}, {name: \"C\", data: Bool([true])}, {name: \"D\", data: Str([\"c\"])}]",
  )
}

test "sum" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 3.5])),
  ])
  let df_sum = df.sum!()
  inspect!(df_sum.data[0].data, content="Int([6])")
  inspect!(df_sum.data[1].data, content="Float([7])")
}

test "sum_horizontal" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.5, 3.0])),
  ])
  let sum = df.sum_horizontal!()
  inspect!(sum.data(), content="Float([2.5, 4.5, 6])")
}

test "min_horizontal" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 1.5])),
  ])
  let min = df.min_horizontal!()
  inspect!(min.data, content="Float([1, 2, 1.5])")
}

test "max_horizontal" {
  let df = DataFrame::new!([
    Series::new("A", SeriesData::Int([1, 2, 3])),
    Series::new("B", SeriesData::Float([1.5, 2.0, 1.5])),
  ])
  let max = df.max_horizontal!()
  inspect!(max.data, content="Float([1.5, 2, 3])")
}
